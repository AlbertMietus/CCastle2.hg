{# (C) Albert Mietus, 2023. Part of Castle/CCastle project #}

{# parameters: ``protocols``: PTH.Sequence[aigr.EventProtocol]
#}
{% import 'macros/CastleMacros.jinja2' as m %}
{#------------------------------------------#}

{%- macro Str_or_Type(t) -%}
  {%- if t is string -%}
    "{{t}}"
  {%- else -%}
    {{t.__name__}}
  {%- endif -%}
{%- endmacro -%}

{%- for proto in protocols %}
##
## The protocol Data Definitions for {{proto.name}} -- with {{proto.events|length}} events
##

{{m.ProtocolName(proto) }} = buildin.CC_B_Protocol(name="{{ proto.name }}",
  {% if proto.typedParameters  %}
                                parameters=(
    {% for parm in proto.typedParameters %}
                                    ('{{ parm.name}}', {{ Str_or_Type(parm.type) }}),
    {% endfor %}
                                ), {#- XXX ToDo: parms: tuple, namedType, strings, ... (see event -- use macro?) #}

  {% endif %}
                                kind=buildin.{{proto.kind}},
                                inherit_from={{proto.based_on.ns.name}}.{{m.ProtocolName(proto.based_on)}}, #XXX# NS works, but isn't done. Add a bit python-abstraction in RPy
                                events=[])

  {% for e in proto.events %}
    {{- m.ProtocolName(proto)}}.events.append(buildin.CC_B_P_EventID(name="{{- e.name -}}",
                                seqNo={{- m.EventIndexName(proto, e) }},
                                part_of={{ m.ProtocolName(proto) }}))
  {% endfor %} {#- event #}

{% endfor %} {#- protocols #}
